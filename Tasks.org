#+property: header-args :session tasks :tangle tasks.py :eval noexport :results output

* Developer tasks
  :PROPERTIES:
  :ID:       68AF78C2-846C-4703-8A49-C9042433E952
  :END:

  Repetitive tasks needed while working on the blog.

  This is meant to be used from your shell:
  
  #+begin_src bash :session none :tangle no :results verbatim
    inv -l
  #+end_src

  #+RESULTS:
  : Available tasks:
  : 
  :   build         Use Jekyll to build the Blog
  :   run           Build+Run the Blog locally
  :   serve         Serves the Blog locally
  :   update-gems   Updates bundler and reinstall all Blog dependencies
  :   view          Open live website in the default browser
  : 
  

  To regenerate [[file:tasks.py]] file, simply tangle it with:
  =C-c C-v t=. 

  
** Python Invoke: [[https://www.pyinvoke.org/][site]]


   #+begin_src python
     from invoke import task     
   #+end_src

   #+RESULTS:

   
** Constants

   #+begin_src python
     DOCKER_JEKYLL_CMD_PARTS = ['docker', 'run',
                                '-v', '`pwd`/org/jekyll:/blog',
                                '-p', '"4000:4000"',
                                'blog:ruby3']

     BUNDLE_EXEC = ['bundle', 'exec']
   #+end_src

   #+RESULTS:


** Command builder helper

   Takes a list of command parts and joins them to construct a valid
   bash command:

   #+begin_src python
     def build_cmd(parts):
         return ' '.join(parts)
   #+end_src

   #+RESULTS: build_cmd

   Example:

   #+begin_src python :tangle no
     result = build_cmd(['echo', 'Hello world!'])
     print(result)
   #+end_src

   #+RESULTS:
   : echo Hello world!

   
** Ruby Gem helper

   Helps keeping all Ruby dependencies up to date:

   #+begin_src python
     @task
     def update_gems(ctx):
         """Updates bundler and reinstall all Blog dependencies"""
         ctx.run('gem update bundler')
         ctx.run('bundle update')
         ctx.run('bundle install')
   #+end_src


** Jekyll helpers
   
   #+begin_src python
     @task(pre=[update_gems])
     def build(ctx, docker=False, trace=False):
         """Use Jekyll to build the Blog"""
         jekyll_build = ['jekyll', 'build']
         if trace:
             jekyll_build.append('--trace')
         if docker is True:
             docker_build = build_cmd(DOCKER_JEKYLL_CMD_PARTS + jekyll_build)
             ctx.run(docker_build)
         else:
             local_build = build_cmd(BUNDLE_EXEC + jekyll_build)
             ctx.run(local_build)


     @task
     def serve(ctx, drafts=True, docker=False, trace=False):
         """Serves the Blog locally"""
         jekyll_serve = ['jekyll', 'serve', '--livereload']
         if drafts:
             jekyll_serve.append('--drafts')
         if trace:
             jekyll_serve.append('--trace')
         if docker:
             docker_serve_cmd = build_cmd(DOCKER_JEKYLL_CMD_PARTS + jekyll_serve)
             ctx.run(docker_serve_cmd)
         else:
             local_serve_cmd = build_cmd(BUNDLE_EXEC + jekyll_serve)
             ctx.run(local_serve_cmd)


     @task
     def run(ctx, docker=False, trace=False, drafts=True):
         """Build+Run the Blog locally"""
         build(ctx, docker=docker, trace=trace)
         serve(ctx, drafts=drafts, docker=docker, trace=trace)


     @task
     def view(ctx):
         """Open live website in the default browser"""
         ctx.run('open https://pgpbpadilla.github.io/')

   #+end_src

   #+RESULTS:
